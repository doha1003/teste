/**
 * WCAG 2.1 AA/AAA 준수 접근성 테스트
 * 웹 접근성 지침을 준수하는지 검증합니다.
 */

import { test, expect } from '@playwright/test';
import { injectAxe, checkA11y, getViolations, reportViolations } from 'axe-playwright';

const TEST_PAGES = [
  { url: '/', name: 'Home Page' },
  { url: '/tests/mbti/', name: 'MBTI Test' },
  { url: '/tests/love-dna/', name: 'Love DNA Test' },
  { url: '/fortune/daily/', name: 'Daily Fortune' },
  { url: '/tools/bmi-calculator.html', name: 'BMI Calculator' },
  { url: '/about/', name: 'About Page' },
  { url: '/contact/', name: 'Contact Page' }
];

// WCAG 2.1 AA 기준 색상 대비 비율
const COLOR_CONTRAST_RATIOS = {
  normal: 4.5,    // 일반 텍스트
  large: 3.0,     // 큰 텍스트 (18pt 이상 또는 14pt bold 이상)
  aaa_normal: 7.0,    // AAA 기준 일반 텍스트
  aaa_large: 4.5      // AAA 기준 큰 텍스트
};

test.describe('WCAG 2.1 접근성 테스트', () => {
  test.beforeEach(async ({ page }) => {\n    // axe-core 라이브러리 주입\n    await injectAxe(page);\n  });\n\n  // 각 페이지별 접근성 검사\n  for (const testPage of TEST_PAGES) {\n    test(`${testPage.name} - WCAG 2.1 AA 준수 검사`, async ({ page }) => {\n      await page.goto(testPage.url);\n      \n      // 페이지 로딩 완료 대기\n      await page.waitForLoadState('networkidle');\n      \n      // axe-core로 접근성 검사 실행\n      await checkA11y(page, null, {\n        detailedReport: true,\n        detailedReportOptions: { html: true },\n        \n        // WCAG 2.1 AA 기준으로 검사\n        tags: ['wcag2a', 'wcag2aa', 'wcag21aa'],\n        \n        // 심각도가 높은 위반사항만 테스트 실패로 처리\n        impactLevels: ['critical', 'serious']\n      });\n      \n      console.log(`✓ ${testPage.name}: WCAG 2.1 AA 준수`);\n    });\n\n    test(`${testPage.name} - WCAG 2.1 AAA 검사 (경고)`, async ({ page }) => {\n      await page.goto(testPage.url);\n      await page.waitForLoadState('networkidle');\n      \n      try {\n        // AAA 기준으로 검사 (실패해도 테스트는 통과)\n        const violations = await page.evaluate(() => {\n          return new Promise((resolve) => {\n            axe.run({\n              tags: ['wcag2aaa', 'wcag21aaa'],\n              runOnly: {\n                type: 'tag',\n                values: ['wcag2aaa', 'wcag21aaa']\n              }\n            }, (err, results) => {\n              if (err) resolve([]);\n              resolve(results.violations || []);\n            });\n          });\n        });\n        \n        if (violations.length > 0) {\n          console.warn(`⚠️  ${testPage.name}: ${violations.length}개의 AAA 기준 개선사항 발견`);\n          violations.forEach(violation => {\n            console.warn(`   - ${violation.description}`);\n          });\n        } else {\n          console.log(`🏆 ${testPage.name}: WCAG 2.1 AAA 완전 준수!`);\n        }\n      } catch (error) {\n        console.warn(`${testPage.name} AAA 검사 중 오류:`, error.message);\n      }\n    });\n  }\n\n  test('색상 대비 비율 검증', async ({ page }) => {\n    await page.goto('/');\n    await page.waitForLoadState('networkidle');\n    \n    // 페이지의 모든 텍스트 요소 색상 대비 검사\n    const contrastResults = await page.evaluate(() => {\n      const results = [];\n      \n      // 모든 텍스트 노드를 포함한 요소들 찾기\n      const textElements = document.querySelectorAll('*');\n      \n      textElements.forEach(element => {\n        const style = window.getComputedStyle(element);\n        const text = element.textContent?.trim();\n        \n        if (text && text.length > 0) {\n          const color = style.color;\n          const backgroundColor = style.backgroundColor;\n          const fontSize = parseFloat(style.fontSize);\n          const fontWeight = style.fontWeight;\n          \n          // 큰 텍스트 여부 판단 (18pt = 24px, 14pt bold = 18.7px)\n          const isLargeText = fontSize >= 24 || (fontSize >= 18.7 && (fontWeight === 'bold' || parseInt(fontWeight) >= 700));\n          \n          results.push({\n            element: element.tagName.toLowerCase(),\n            text: text.substring(0, 50) + (text.length > 50 ? '...' : ''),\n            color,\n            backgroundColor,\n            fontSize,\n            fontWeight,\n            isLargeText\n          });\n        }\n      });\n      \n      return results.slice(0, 20); // 처음 20개만 검사\n    });\n    \n    console.log(`색상 대비 검사 대상: ${contrastResults.length}개 요소`);\n    \n    // 각 텍스트 요소의 색상 대비 확인\n    let contrastIssues = 0;\n    \n    for (const result of contrastResults) {\n      if (result.color === 'rgba(0, 0, 0, 0)' || result.backgroundColor === 'rgba(0, 0, 0, 0)') {\n        continue; // 투명한 색상은 건너뛰기\n      }\n      \n      // 실제 색상 대비 계산은 복잡하므로 여기서는 기본적인 검사만 수행\n      // 실제 프로덕션에서는 contrast 라이브러리나 axe-core 결과를 사용\n      \n      const isBlackOnWhite = result.color.includes('rgb(0, 0, 0)') && \n                            (result.backgroundColor.includes('rgb(255, 255, 255)') || \n                             result.backgroundColor === 'rgba(0, 0, 0, 0)');\n      \n      const isWhiteOnDark = result.color.includes('rgb(255, 255, 255)') && \n                           !result.backgroundColor.includes('rgb(255, 255, 255)');\n      \n      if (!isBlackOnWhite && !isWhiteOnDark && \n          !result.color.includes('rgb(51, 51, 51)') && // 일반적으로 충분한 대비를 가진 어두운 회색\n          !result.color.includes('rgb(33, 37, 41)')) {  // Bootstrap의 기본 다크 색상\n        contrastIssues++;\n        console.warn(`색상 대비 검토 필요: ${result.element} - \"${result.text}\"`);\n        console.warn(`  색상: ${result.color}, 배경: ${result.backgroundColor}`);\n      }\n    }\n    \n    // 심각한 대비 문제가 없어야 함 (전체의 10% 미만)\n    expect(contrastIssues / contrastResults.length).toBeLessThan(0.1);\n  });\n\n  test('키보드 네비게이션 완전성 검사', async ({ page }) => {\n    await page.goto('/');\n    await page.waitForLoadState('networkidle');\n    \n    // 모든 상호작용 가능한 요소들 찾기\n    const interactiveElements = await page.evaluate(() => {\n      const selectors = [\n        'a[href]',\n        'button:not([disabled])',\n        'input:not([disabled])',\n        'select:not([disabled])',\n        'textarea:not([disabled])',\n        '[tabindex]:not([tabindex=\"-1\"])',\n        '[role=\"button\"]',\n        '[role=\"link\"]',\n        '[role=\"menuitem\"]',\n        '[role=\"tab\"]'\n      ];\n      \n      const elements = [];\n      selectors.forEach(selector => {\n        const found = document.querySelectorAll(selector);\n        found.forEach(el => {\n          if (el.offsetParent !== null) { // 보이는 요소만\n            elements.push({\n              tagName: el.tagName.toLowerCase(),\n              type: el.type || null,\n              role: el.role || null,\n              tabIndex: el.tabIndex,\n              text: el.textContent?.trim().substring(0, 30) || '',\n              hasAriaLabel: !!el.getAttribute('aria-label'),\n              hasTitle: !!el.title\n            });\n          }\n        });\n      });\n      \n      return elements;\n    });\n    \n    console.log(`상호작용 요소 ${interactiveElements.length}개 발견`);\n    \n    // Tab 키로 순회 가능한지 확인\n    let focusableCount = 0;\n    let currentIndex = 0;\n    \n    while (currentIndex < Math.min(interactiveElements.length, 20) && focusableCount < 20) {\n      await page.keyboard.press('Tab');\n      \n      const focusedElement = await page.evaluate(() => {\n        const active = document.activeElement;\n        return active ? {\n          tagName: active.tagName.toLowerCase(),\n          text: active.textContent?.trim().substring(0, 30) || ''\n        } : null;\n      });\n      \n      if (focusedElement) {\n        focusableCount++;\n        console.log(`Tab ${focusableCount}: ${focusedElement.tagName} - \"${focusedElement.text}\"`);\n      }\n      \n      currentIndex++;\n      \n      // 무한 루프 방지\n      if (currentIndex > 30) break;\n    }\n    \n    // 최소한 몇 개의 요소는 포커스 가능해야 함\n    expect(focusableCount).toBeGreaterThan(3);\n    \n    // 포커스 트랩 확인 (모달이 있는 경우)\n    const modalElements = await page.locator('[role=\"dialog\"], .modal').count();\n    if (modalElements > 0) {\n      console.log('모달 요소 발견 - 포커스 트랩 확인 필요');\n    }\n  });\n\n  test('스크린 리더 호환성 검사', async ({ page }) => {\n    await page.goto('/');\n    await page.waitForLoadState('networkidle');\n    \n    // ARIA 레이블과 역할 검사\n    const ariaResults = await page.evaluate(() => {\n      const results = {\n        missingAltImages: [],\n        unlabeledInputs: [],\n        missingHeadingStructure: [],\n        missingLandmarks: [],\n        improperARIA: []\n      };\n      \n      // 이미지 alt 속성 검사\n      const images = document.querySelectorAll('img');\n      images.forEach((img, index) => {\n        if (!img.alt && img.alt !== '') {\n          results.missingAltImages.push({\n            src: img.src,\n            index\n          });\n        }\n      });\n      \n      // 입력 필드 레이블 검사\n      const inputs = document.querySelectorAll('input, select, textarea');\n      inputs.forEach((input, index) => {\n        const hasLabel = document.querySelector(`label[for=\"${input.id}\"]`) || \n                        input.getAttribute('aria-label') || \n                        input.getAttribute('aria-labelledby') ||\n                        input.getAttribute('title');\n        \n        if (!hasLabel && input.type !== 'hidden' && input.type !== 'submit' && input.type !== 'button') {\n          results.unlabeledInputs.push({\n            type: input.type,\n            name: input.name,\n            index\n          });\n        }\n      });\n      \n      // 제목 계층구조 검사\n      const headings = document.querySelectorAll('h1, h2, h3, h4, h5, h6');\n      let previousLevel = 0;\n      headings.forEach((heading, index) => {\n        const level = parseInt(heading.tagName.charAt(1));\n        \n        if (index === 0 && level !== 1) {\n          results.missingHeadingStructure.push('첫 번째 제목이 h1이 아님');\n        }\n        \n        if (level > previousLevel + 1) {\n          results.missingHeadingStructure.push(`h${previousLevel}에서 h${level}로 건너뜀`);\n        }\n        \n        previousLevel = level;\n      });\n      \n      // 랜드마크 역할 검사\n      const landmarks = {\n        main: document.querySelectorAll('main, [role=\"main\"]').length,\n        nav: document.querySelectorAll('nav, [role=\"navigation\"]').length,\n        header: document.querySelectorAll('header, [role=\"banner\"]').length,\n        footer: document.querySelectorAll('footer, [role=\"contentinfo\"]').length\n      };\n      \n      if (landmarks.main === 0) results.missingLandmarks.push('main');\n      if (landmarks.header === 0) results.missingLandmarks.push('header');\n      if (landmarks.footer === 0) results.missingLandmarks.push('footer');\n      \n      // ARIA 속성 유효성 검사\n      const elementsWithAria = document.querySelectorAll('[aria-label], [aria-labelledby], [aria-describedby], [role]');\n      elementsWithAria.forEach((element, index) => {\n        const role = element.getAttribute('role');\n        const ariaLabel = element.getAttribute('aria-label');\n        const ariaLabelledby = element.getAttribute('aria-labelledby');\n        \n        // 빈 aria-label 확인\n        if (ariaLabel === '') {\n          results.improperARIA.push(`빈 aria-label (인덱스: ${index})`);\n        }\n        \n        // aria-labelledby가 존재하지 않는 요소를 참조하는지 확인\n        if (ariaLabelledby) {\n          const referenced = document.getElementById(ariaLabelledby);\n          if (!referenced) {\n            results.improperARIA.push(`존재하지 않는 요소 참조: ${ariaLabelledby}`);\n          }\n        }\n      });\n      \n      return results;\n    });\n    \n    // 결과 검증 및 보고\n    console.log('스크린 리더 호환성 검사 결과:');\n    \n    if (ariaResults.missingAltImages.length > 0) {\n      console.warn(`Alt 속성 누락 이미지: ${ariaResults.missingAltImages.length}개`);\n      // 중요한 이미지의 alt 속성은 필수\n      expect(ariaResults.missingAltImages.length).toBeLessThan(3);\n    }\n    \n    if (ariaResults.unlabeledInputs.length > 0) {\n      console.warn(`레이블 누락 입력 필드: ${ariaResults.unlabeledInputs.length}개`);\n      // 모든 입력 필드는 레이블이 있어야 함\n      expect(ariaResults.unlabeledInputs.length).toBe(0);\n    }\n    \n    if (ariaResults.missingHeadingStructure.length > 0) {\n      console.warn('제목 계층구조 문제:', ariaResults.missingHeadingStructure);\n      // 제목 구조는 논리적이어야 함\n      expect(ariaResults.missingHeadingStructure.length).toBeLessThan(2);\n    }\n    \n    if (ariaResults.missingLandmarks.length > 0) {\n      console.warn('누락된 랜드마크:', ariaResults.missingLandmarks);\n      // main 랜드마크는 필수\n      expect(ariaResults.missingLandmarks).not.toContain('main');\n    }\n    \n    if (ariaResults.improperARIA.length > 0) {\n      console.warn('부적절한 ARIA 사용:', ariaResults.improperARIA);\n      expect(ariaResults.improperARIA.length).toBe(0);\n    }\n    \n    console.log('✓ 스크린 리더 호환성 검사 완료');\n  });\n\n  test('모바일 접근성 검사', async ({ page }) => {\n    // 모바일 뷰포트 설정\n    await page.setViewportSize({ width: 375, height: 667 });\n    await page.goto('/');\n    await page.waitForLoadState('networkidle');\n    \n    // 터치 타겟 크기 검사\n    const touchTargets = await page.evaluate(() => {\n      const interactiveElements = document.querySelectorAll(\n        'button, a, input, select, textarea, [role=\"button\"], [tabindex]:not([tabindex=\"-1\"])'\n      );\n      \n      const results = [];\n      interactiveElements.forEach((element, index) => {\n        if (element.offsetParent !== null) { // 보이는 요소만\n          const rect = element.getBoundingClientRect();\n          results.push({\n            index,\n            tagName: element.tagName.toLowerCase(),\n            width: rect.width,\n            height: rect.height,\n            area: rect.width * rect.height,\n            text: element.textContent?.trim().substring(0, 20) || ''\n          });\n        }\n      });\n      \n      return results;\n    });\n    \n    console.log(`모바일 터치 타겟 검사: ${touchTargets.length}개 요소`);\n    \n    let smallTargets = 0;\n    const minTouchSize = 44; // 44px는 WCAG 권장 최소 터치 타겟 크기\n    \n    touchTargets.forEach(target => {\n      if (target.width < minTouchSize || target.height < minTouchSize) {\n        smallTargets++;\n        console.warn(`작은 터치 타겟: ${target.tagName} \"${target.text}\" (${Math.round(target.width)}x${Math.round(target.height)}px)`);\n      }\n    });\n    \n    // 80% 이상의 터치 타겟이 적절한 크기여야 함\n    const appropriateTargetRatio = (touchTargets.length - smallTargets) / touchTargets.length;\n    expect(appropriateTargetRatio).toBeGreaterThan(0.8);\n    \n    console.log(`적절한 크기의 터치 타겟 비율: ${Math.round(appropriateTargetRatio * 100)}%`);\n    \n    // 뷰포트 메타 태그 확인\n    const viewport = await page.locator('meta[name=\"viewport\"]').getAttribute('content');\n    expect(viewport).toBeTruthy();\n    expect(viewport).toContain('width=device-width');\n    \n    console.log('✓ 모바일 접근성 검사 완료');\n  });\n\n  test('다크 모드 접근성 검사', async ({ page }) => {\n    await page.goto('/');\n    await page.waitForLoadState('networkidle');\n    \n    // 다크 모드 활성화 (테마 토글 버튼이 있는 경우)\n    const themeToggle = page.locator('.theme-toggle, .dark-mode-toggle, [data-theme-toggle]');\n    \n    if (await themeToggle.isVisible()) {\n      await themeToggle.click();\n      await page.waitForTimeout(500); // 테마 전환 애니메이션 대기\n      \n      // 다크 모드에서 색상 대비 검사\n      const darkModeViolations = await page.evaluate(() => {\n        return new Promise((resolve) => {\n          if (typeof axe !== 'undefined') {\n            axe.run({\n              rules: {\n                'color-contrast': { enabled: true }\n              }\n            }, (err, results) => {\n              if (err) resolve([]);\n              resolve(results.violations || []);\n            });\n          } else {\n            resolve([]);\n          }\n        });\n      });\n      \n      const contrastViolations = darkModeViolations.filter(v => v.id === 'color-contrast');\n      \n      if (contrastViolations.length > 0) {\n        console.warn(`다크 모드 색상 대비 문제: ${contrastViolations.length}개 발견`);\n        contrastViolations.forEach(violation => {\n          console.warn(`  - ${violation.description}`);\n        });\n      } else {\n        console.log('✓ 다크 모드 색상 대비 적절함');\n      }\n      \n      // 다크 모드에서도 색상 대비 위반사항이 심각하지 않아야 함\n      expect(contrastViolations.length).toBeLessThan(5);\n      \n      // 라이트 모드로 복귀\n      await themeToggle.click();\n      await page.waitForTimeout(500);\n    } else {\n      console.log('테마 토글 버튼을 찾을 수 없음 - 다크 모드 테스트 건너뜀');\n    }\n  });\n\n  test('폼 접근성 검사', async ({ page }) => {\n    // 폼이 있는 페이지로 이동\n    await page.goto('/contact/');\n    await page.waitForLoadState('networkidle');\n    \n    // 폼 요소들의 접근성 검사\n    const formAccessibility = await page.evaluate(() => {\n      const results = {\n        formsWithFieldsets: 0,\n        formsWithLegends: 0,\n        inputsWithLabels: 0,\n        inputsWithoutLabels: 0,\n        inputsWithPlaceholderOnly: 0,\n        requiredFieldsWithAria: 0,\n        requiredFieldsWithoutAria: 0,\n        errorFieldsWithAria: 0\n      };\n      \n      // 폼 그룹화 검사\n      const forms = document.querySelectorAll('form');\n      forms.forEach(form => {\n        const fieldsets = form.querySelectorAll('fieldset');\n        const legends = form.querySelectorAll('legend');\n        \n        if (fieldsets.length > 0) results.formsWithFieldsets++;\n        if (legends.length > 0) results.formsWithLegends++;\n      });\n      \n      // 입력 필드 레이블 검사\n      const inputs = document.querySelectorAll('input:not([type=\"hidden\"]):not([type=\"submit\"]):not([type=\"button\"]), select, textarea');\n      inputs.forEach(input => {\n        const hasLabel = document.querySelector(`label[for=\"${input.id}\"]`) ||\n                        input.getAttribute('aria-label') ||\n                        input.getAttribute('aria-labelledby');\n        \n        const hasPlaceholder = input.placeholder;\n        const isRequired = input.required || input.getAttribute('aria-required') === 'true';\n        const hasError = input.getAttribute('aria-invalid') === 'true' ||\n                         input.getAttribute('aria-describedby');\n        \n        if (hasLabel) {\n          results.inputsWithLabels++;\n        } else {\n          results.inputsWithoutLabels++;\n          \n          if (hasPlaceholder && !hasLabel) {\n            results.inputsWithPlaceholderOnly++;\n          }\n        }\n        \n        if (isRequired) {\n          if (input.getAttribute('aria-required') === 'true' || input.required) {\n            results.requiredFieldsWithAria++;\n          } else {\n            results.requiredFieldsWithoutAria++;\n          }\n        }\n        \n        if (hasError) {\n          results.errorFieldsWithAria++;\n        }\n      });\n      \n      return results;\n    });\n    \n    console.log('폼 접근성 검사 결과:', formAccessibility);\n    \n    // 모든 입력 필드는 적절한 레이블이 있어야 함\n    if (formAccessibility.inputsWithLabels + formAccessibility.inputsWithoutLabels > 0) {\n      const labeledRatio = formAccessibility.inputsWithLabels / \n                          (formAccessibility.inputsWithLabels + formAccessibility.inputsWithoutLabels);\n      expect(labeledRatio).toBeGreaterThan(0.9); // 90% 이상\n    }\n    \n    // placeholder만 있는 필드는 접근성 문제\n    expect(formAccessibility.inputsWithPlaceholderOnly).toBeLessThan(2);\n    \n    // 필수 필드는 aria-required 속성이 있어야 함\n    if (formAccessibility.requiredFieldsWithAria + formAccessibility.requiredFieldsWithoutAria > 0) {\n      expect(formAccessibility.requiredFieldsWithoutAria).toBe(0);\n    }\n    \n    console.log('✓ 폼 접근성 검사 완료');\n  });\n\n  test('동적 콘텐츠 접근성 검사', async ({ page }) => {\n    await page.goto('/tests/mbti/');\n    await page.waitForLoadState('networkidle');\n    \n    // 라이브 리전 확인\n    const liveRegions = await page.locator('[aria-live]').count();\n    console.log(`라이브 리전 ${liveRegions}개 발견`);\n    \n    // 동적 업데이트가 있는 요소들 확인\n    const dynamicElements = await page.evaluate(() => {\n      const results = [];\n      \n      // 진행률 표시기\n      const progressBars = document.querySelectorAll('[role=\"progressbar\"], .progress');\n      progressBars.forEach(bar => {\n        results.push({\n          type: 'progressbar',\n          hasAriaValueNow: !!bar.getAttribute('aria-valuenow'),\n          hasAriaValueMax: !!bar.getAttribute('aria-valuemax'),\n          hasAriaLabel: !!bar.getAttribute('aria-label') || !!bar.getAttribute('aria-labelledby')\n        });\n      });\n      \n      // 경고/알림 메시지\n      const alerts = document.querySelectorAll('[role=\"alert\"], .alert, .error, .warning');\n      alerts.forEach(alert => {\n        results.push({\n          type: 'alert',\n          hasAriaLive: !!alert.getAttribute('aria-live'),\n          hasRole: !!alert.getAttribute('role')\n        });\n      });\n      \n      return results;\n    });\n    \n    // 진행률 표시기의 접근성 확인\n    const progressBars = dynamicElements.filter(el => el.type === 'progressbar');\n    progressBars.forEach(bar => {\n      expect(bar.hasAriaValueNow).toBe(true);\n      expect(bar.hasAriaValueMax).toBe(true);\n    });\n    \n    // 경고 메시지의 접근성 확인\n    const alerts = dynamicElements.filter(el => el.type === 'alert');\n    alerts.forEach(alert => {\n      expect(alert.hasAriaLive || alert.hasRole).toBe(true);\n    });\n    \n    console.log('✓ 동적 콘텐츠 접근성 검사 완료');\n  });\n\n  test('다국어 접근성 검사', async ({ page }) => {\n    await page.goto('/');\n    await page.waitForLoadState('networkidle');\n    \n    // 언어 관련 속성 검사\n    const langResults = await page.evaluate(() => {\n      const results = {\n        htmlLang: document.documentElement.lang,\n        elementsWithLang: document.querySelectorAll('[lang]').length,\n        directionality: document.documentElement.dir || 'ltr'\n      };\n      \n      return results;\n    });\n    \n    console.log('언어 접근성 검사 결과:', langResults);\n    \n    // HTML 요소에 lang 속성이 있어야 함\n    expect(langResults.htmlLang).toBeTruthy();\n    expect(langResults.htmlLang).toBe('ko'); // 한국어 사이트\n    \n    // 텍스트 방향성 확인 (한국어는 LTR)\n    expect(langResults.directionality).toBe('ltr');\n    \n    console.log('✓ 다국어 접근성 검사 완료');\n  });\n});\n\n// 접근성 테스트 결과 리포트 생성\ntest.afterAll(async () => {\n  console.log('\\n=== 접근성 테스트 완료 ===');\n  console.log('모든 WCAG 2.1 AA 기준 테스트가 완료되었습니다.');\n  console.log('추가 개선사항은 AAA 기준 경고 메시지를 참고하세요.');\n});"