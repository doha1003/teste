/**
 * App Shell Manager
 * PWA App Shell 아키텍처 구현
 * 
 * Features:
 * - Critical UI 빠른 로딩
 * - 점진적 콘텐츠 로딩
 * - 오프라인 shell 지원
 * - 네이티브 앱 수준의 사용자 경험
 */

class AppShell {
  constructor() {
    this.config = {
      // App Shell 컴포넌트들
      shell: {
        navbar: '#navbar-placeholder',
        footer: '#footer-placeholder',
        mainContent: 'main',
        loadingIndicator: '.loading-indicator',
      },
      
      // 로딩 상태
      loading: {
        shellLoaded: false,
        contentLoaded: false,
        componentsLoaded: new Set(),
      },
      
      // 캐시 설정
      cache: {
        shellComponents: [
          '/includes/navbar.html',
          '/includes/footer.html',
        ],
        criticalCSS: [
          '/dist/styles.min.css',
          '/css/design-system/tokens.css',
        ],
        criticalJS: [
          '/js/app.js',
          '/js/core/common-init.js',
        ],
      },
      
      // 성능 임계값
      performance: {
        shellTimeout: 2000,  // 2초 내 Shell 로딩
        contentTimeout: 5000, // 5초 내 콘텐츠 로딩
        criticalResourceTimeout: 3000, // 3초 내 핵심 리소스
      },
      
      // 애니메이션 설정
      animations: {
        shellFadeIn: 200,
        contentSlideIn: 300,
        skeletonPulse: 1500,
      },
    };
    
    this.loadStartTime = performance.now();
    this.metrics = {
      shellLoadTime: 0,
      contentLoadTime: 0,
      totalLoadTime: 0,
      resourceLoadTimes: new Map(),
    };
    
    this.init();
  }
  
  /**
   * App Shell 초기화
   */
  init() {
    // 성능 측정 시작
    this.startPerformanceTracking();
    
    // Shell 우선 로딩
    this.loadShell();
    
    // 컨텐츠 지연 로딩
    this.scheduleContentLoading();
    
    // 오프라인 감지 및 처리
    this.setupOfflineHandling();
    
    // 설치 프롬프트 관리
    this.setupInstallPrompt();
  }
  
  /**
   * App Shell 로딩
   */
  async loadShell() {
    try {
      // 스켈레톤 UI 표시
      this.showSkeletonUI();
      
      // 병렬로 Shell 컴포넌트 로딩
      const shellPromises = [
        this.loadComponent('navbar', this.config.shell.navbar),
        this.loadComponent('footer', this.config.shell.footer),
        this.preloadCriticalResources(),
      ];
      
      await Promise.allSettled(shellPromises);
      
      // Shell 로딩 완료
      this.config.loading.shellLoaded = true;
      this.metrics.shellLoadTime = performance.now() - this.loadStartTime;
      
      // Shell UI 표시
      this.showShell();
      
      // Shell 로딩 이벤트 발송
      this.dispatchEvent('shell:loaded', {
        loadTime: this.metrics.shellLoadTime,
        timestamp: Date.now(),
      });\n      \n    } catch (error) {\n      console.error('[App Shell] Shell 로딩 실패:', error);\n      this.handleShellLoadError(error);\n    }\n  }\n  \n  /**\n   * 컴포넌트 로딩\n   */\n  async loadComponent(name, selector) {\n    const startTime = performance.now();\n    \n    try {\n      const element = document.querySelector(selector);\n      if (!element) {\n        throw new Error(`Element not found: ${selector}`);\n      }\n      \n      // 캐시에서 먼저 확인\n      let html = await this.getFromCache(`component:${name}`);\n      \n      if (!html) {\n        // 네트워크에서 로딩\n        const response = await fetch(`/includes/${name}.html`);\n        if (!response.ok) {\n          throw new Error(`HTTP ${response.status}`);\n        }\n        html = await response.text();\n        \n        // 캐시에 저장\n        await this.saveToCache(`component:${name}`, html);\n      }\n      \n      // DOM에 삽입\n      element.innerHTML = html;\n      \n      // 컴포넌트별 초기화\n      await this.initializeComponent(name, element);\n      \n      // 로딩 완료 표시\n      this.config.loading.componentsLoaded.add(name);\n      \n      const loadTime = performance.now() - startTime;\n      this.metrics.resourceLoadTimes.set(name, loadTime);\n      \n      console.log(`[App Shell] ${name} 컴포넌트 로딩 완료 (${loadTime.toFixed(2)}ms)`);\n      \n    } catch (error) {\n      console.error(`[App Shell] ${name} 컴포넌트 로딩 실패:`, error);\n      \n      // 오프라인 폴백\n      await this.loadOfflineFallback(name, selector);\n    }\n  }\n  \n  /**\n   * 핵심 리소스 프리로딩\n   */\n  async preloadCriticalResources() {\n    const preloadPromises = [];\n    \n    // CSS 프리로딩\n    for (const cssUrl of this.config.cache.criticalCSS) {\n      preloadPromises.push(this.preloadResource(cssUrl, 'style'));\n    }\n    \n    // JS 프리로딩 (이미 로드된 것 제외)\n    for (const jsUrl of this.config.cache.criticalJS) {\n      if (!this.isScriptLoaded(jsUrl)) {\n        preloadPromises.push(this.preloadResource(jsUrl, 'script'));\n      }\n    }\n    \n    await Promise.allSettled(preloadPromises);\n  }\n  \n  /**\n   * 리소스 프리로딩\n   */\n  async preloadResource(url, type) {\n    return new Promise((resolve, reject) => {\n      const element = document.createElement('link');\n      element.rel = 'preload';\n      element.href = url;\n      element.as = type;\n      \n      if (type === 'style') {\n        element.onload = () => {\n          // CSS를 실제로 적용\n          const linkElement = document.createElement('link');\n          linkElement.rel = 'stylesheet';\n          linkElement.href = url;\n          document.head.appendChild(linkElement);\n          resolve();\n        };\n      } else {\n        element.onload = resolve;\n      }\n      \n      element.onerror = reject;\n      \n      // 타임아웃 설정\n      setTimeout(() => {\n        reject(new Error(`Preload timeout: ${url}`));\n      }, this.config.performance.criticalResourceTimeout);\n      \n      document.head.appendChild(element);\n    });\n  }\n  \n  /**\n   * 컨텐츠 로딩 스케줄링\n   */\n  scheduleContentLoading() {\n    // Shell 로딩 후 컨텐츠 로딩\n    const checkShellReady = () => {\n      if (this.config.loading.shellLoaded) {\n        this.loadContent();\n      } else {\n        setTimeout(checkShellReady, 50);\n      }\n    };\n    \n    setTimeout(checkShellReady, 100);\n  }\n  \n  /**\n   * 컨텐츠 로딩\n   */\n  async loadContent() {\n    try {\n      const contentStartTime = performance.now();\n      \n      // 페이지별 컨텐츠 로딩\n      await this.loadPageContent();\n      \n      // 비핵심 리소스 지연 로딩\n      this.scheduleNonCriticalLoading();\n      \n      // 컨텐츠 로딩 완료\n      this.config.loading.contentLoaded = true;\n      this.metrics.contentLoadTime = performance.now() - contentStartTime;\n      this.metrics.totalLoadTime = performance.now() - this.loadStartTime;\n      \n      // 스켈레톤 UI 숨기기\n      this.hideSkeletonUI();\n      \n      // 컨텐츠 표시\n      this.showContent();\n      \n      // 로딩 완료 이벤트\n      this.dispatchEvent('content:loaded', {\n        contentLoadTime: this.metrics.contentLoadTime,\n        totalLoadTime: this.metrics.totalLoadTime,\n      });\n      \n      // 성능 메트릭 보고\n      this.reportPerformanceMetrics();\n      \n    } catch (error) {\n      console.error('[App Shell] 컨텐츠 로딩 실패:', error);\n      this.handleContentLoadError(error);\n    }\n  }\n  \n  /**\n   * 페이지별 컨텐츠 로딩\n   */\n  async loadPageContent() {\n    const page = document.documentElement.dataset.page || 'home';\n    \n    try {\n      // 페이지별 스크립트 동적 로딩\n      const pageScript = `/js/pages/${page}.js`;\n      if (await this.resourceExists(pageScript)) {\n        await this.loadScript(pageScript);\n      }\n      \n      // 페이지별 추가 리소스 로딩\n      await this.loadPageSpecificResources(page);\n      \n    } catch (error) {\n      console.warn(`[App Shell] 페이지 컨텐츠 로딩 경고 (${page}):`, error);\n    }\n  }\n  \n  /**\n   * 스켈레톤 UI 표시\n   */\n  showSkeletonUI() {\n    // 스켈레톤 HTML 생성\n    const skeletonHTML = this.generateSkeletonHTML();\n    \n    // 메인 컨텐츠 영역에 스켈레톤 삽입\n    const mainElement = document.querySelector(this.config.shell.mainContent);\n    if (mainElement) {\n      const skeletonContainer = document.createElement('div');\n      skeletonContainer.id = 'app-shell-skeleton';\n      skeletonContainer.innerHTML = skeletonHTML;\n      skeletonContainer.style.cssText = `\n        opacity: 1;\n        transition: opacity ${this.config.animations.shellFadeIn}ms ease;\n      `;\n      \n      mainElement.appendChild(skeletonContainer);\n    }\n  }\n  \n  /**\n   * 스켈레톤 HTML 생성\n   */\n  generateSkeletonHTML() {\n    return `\n      <div class=\"skeleton-container\">\n        <div class=\"skeleton-header\">\n          <div class=\"skeleton-line skeleton-title\"></div>\n          <div class=\"skeleton-line skeleton-subtitle\"></div>\n        </div>\n        \n        <div class=\"skeleton-content\">\n          <div class=\"skeleton-card\">\n            <div class=\"skeleton-line\"></div>\n            <div class=\"skeleton-line\"></div>\n            <div class=\"skeleton-line short\"></div>\n          </div>\n          \n          <div class=\"skeleton-card\">\n            <div class=\"skeleton-line\"></div>\n            <div class=\"skeleton-line\"></div>\n            <div class=\"skeleton-line short\"></div>\n          </div>\n          \n          <div class=\"skeleton-card\">\n            <div class=\"skeleton-line\"></div>\n            <div class=\"skeleton-line\"></div>\n            <div class=\"skeleton-line short\"></div>\n          </div>\n        </div>\n      </div>\n      \n      <style>\n        .skeleton-container {\n          padding: 2rem 1rem;\n          max-width: 1200px;\n          margin: 0 auto;\n        }\n        \n        .skeleton-header {\n          margin-bottom: 2rem;\n          text-align: center;\n        }\n        \n        .skeleton-line {\n          height: 16px;\n          background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%);\n          background-size: 200% 100%;\n          animation: skeleton-loading ${this.config.animations.skeletonPulse}ms infinite;\n          border-radius: 4px;\n          margin-bottom: 12px;\n        }\n        \n        .skeleton-title {\n          height: 32px;\n          width: 60%;\n          margin: 0 auto 16px;\n        }\n        \n        .skeleton-subtitle {\n          height: 20px;\n          width: 40%;\n          margin: 0 auto;\n        }\n        \n        .skeleton-content {\n          display: grid;\n          grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));\n          gap: 1.5rem;\n        }\n        \n        .skeleton-card {\n          padding: 1.5rem;\n          border: 1px solid #e5e7eb;\n          border-radius: 8px;\n          background: white;\n        }\n        \n        .skeleton-line.short {\n          width: 60%;\n        }\n        \n        @keyframes skeleton-loading {\n          0% { background-position: 200% 0; }\n          100% { background-position: -200% 0; }\n        }\n        \n        @media (max-width: 768px) {\n          .skeleton-container { padding: 1rem; }\n          .skeleton-content { grid-template-columns: 1fr; }\n        }\n      </style>\n    `;\n  }\n  \n  /**\n   * Shell 표시\n   */\n  showShell() {\n    document.body.classList.add('shell-loaded');\n    \n    // Shell 컴포넌트들 fade-in 애니메이션\n    const shellElements = [\n      document.querySelector(this.config.shell.navbar),\n      document.querySelector(this.config.shell.footer),\n    ];\n    \n    shellElements.forEach((element, index) => {\n      if (element) {\n        element.style.cssText = `\n          opacity: 0;\n          transform: translateY(-10px);\n          transition: opacity ${this.config.animations.shellFadeIn}ms ease ${index * 100}ms,\n                      transform ${this.config.animations.shellFadeIn}ms ease ${index * 100}ms;\n        `;\n        \n        // 애니메이션 트리거\n        setTimeout(() => {\n          element.style.opacity = '1';\n          element.style.transform = 'translateY(0)';\n        }, 50);\n      }\n    });\n  }\n  \n  /**\n   * 컨텐츠 표시\n   */\n  showContent() {\n    const mainElement = document.querySelector(this.config.shell.mainContent);\n    if (mainElement) {\n      mainElement.classList.add('content-loaded');\n      \n      // 컨텐츠 slide-in 애니메이션\n      const contentElements = mainElement.querySelectorAll(':scope > *:not(#app-shell-skeleton)');\n      \n      contentElements.forEach((element, index) => {\n        element.style.cssText = `\n          opacity: 0;\n          transform: translateY(20px);\n          transition: opacity ${this.config.animations.contentSlideIn}ms ease ${index * 50}ms,\n                      transform ${this.config.animations.contentSlideIn}ms ease ${index * 50}ms;\n        `;\n        \n        setTimeout(() => {\n          element.style.opacity = '1';\n          element.style.transform = 'translateY(0)';\n        }, 100);\n      });\n    }\n  }\n  \n  /**\n   * 스켈레톤 UI 숨기기\n   */\n  hideSkeletonUI() {\n    const skeleton = document.getElementById('app-shell-skeleton');\n    if (skeleton) {\n      skeleton.style.opacity = '0';\n      \n      setTimeout(() => {\n        skeleton.remove();\n      }, this.config.animations.shellFadeIn);\n    }\n  }\n  \n  /**\n   * 오프라인 처리 설정\n   */\n  setupOfflineHandling() {\n    window.addEventListener('online', () => {\n      this.handleOnlineStateChange(true);\n    });\n    \n    window.addEventListener('offline', () => {\n      this.handleOnlineStateChange(false);\n    });\n    \n    // 초기 온라인 상태 확인\n    this.updateOnlineStatus(navigator.onLine);\n  }\n  \n  /**\n   * 온라인 상태 변경 처리\n   */\n  handleOnlineStateChange(isOnline) {\n    this.updateOnlineStatus(isOnline);\n    \n    if (isOnline) {\n      // 온라인 복구 시 대기 중인 리소스 로딩\n      this.retryFailedLoading();\n    } else {\n      // 오프라인 모드 UI 표시\n      this.showOfflineIndicator();\n    }\n  }\n  \n  /**\n   * 온라인 상태 업데이트\n   */\n  updateOnlineStatus(isOnline) {\n    document.body.classList.toggle('offline', !isOnline);\n    document.body.classList.toggle('online', isOnline);\n    \n    // 이벤트 발송\n    this.dispatchEvent('connectivity:changed', {\n      online: isOnline,\n      timestamp: Date.now(),\n    });\n  }\n  \n  /**\n   * 설치 프롬프트 설정\n   */\n  setupInstallPrompt() {\n    let deferredPrompt = null;\n    \n    window.addEventListener('beforeinstallprompt', (e) => {\n      e.preventDefault();\n      deferredPrompt = e;\n      \n      // 설치 프롬프트 UI 표시\n      this.showInstallPrompt(deferredPrompt);\n    });\n    \n    // 설치 완료 감지\n    window.addEventListener('appinstalled', () => {\n      this.handleAppInstalled();\n    });\n  }\n  \n  /**\n   * 설치 프롬프트 표시\n   */\n  showInstallPrompt(deferredPrompt) {\n    // 이미 설치된 경우 프롬프트 표시하지 않음\n    if (window.matchMedia('(display-mode: standalone)').matches) {\n      return;\n    }\n    \n    // 사용자가 이미 거부한 경우 확인\n    const dismissed = localStorage.getItem('pwa-install-dismissed');\n    if (dismissed && Date.now() - parseInt(dismissed) < 7 * 24 * 60 * 60 * 1000) {\n      return; // 7일 동안 표시하지 않음\n    }\n    \n    // 설치 프롬프트 UI 생성\n    const installBanner = this.createInstallPromptUI(deferredPrompt);\n    document.body.appendChild(installBanner);\n    \n    // 애니메이션과 함께 표시\n    setTimeout(() => {\n      installBanner.classList.add('visible');\n    }, 2000); // 2초 후 표시\n  }\n  \n  /**\n   * 설치 프롬프트 UI 생성\n   */\n  createInstallPromptUI(deferredPrompt) {\n    const banner = document.createElement('div');\n    banner.id = 'pwa-install-banner';\n    banner.innerHTML = `\n      <div class=\"install-content\">\n        <div class=\"install-icon\">📱</div>\n        <div class=\"install-text\">\n          <div class=\"install-title\">앱으로 설치하기</div>\n          <div class=\"install-subtitle\">더 빠르고 편리하게 이용하세요</div>\n        </div>\n        <div class=\"install-actions\">\n          <button class=\"install-btn install-btn--primary\" id=\"install-accept\">\n            설치\n          </button>\n          <button class=\"install-btn install-btn--secondary\" id=\"install-dismiss\">\n            나중에\n          </button>\n        </div>\n      </div>\n    `;\n    \n    // 스타일 적용\n    banner.style.cssText = `\n      position: fixed;\n      bottom: -120px;\n      left: 16px;\n      right: 16px;\n      background: white;\n      border-radius: 12px;\n      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.12);\n      z-index: 1000;\n      transition: bottom 300ms ease;\n      border: 1px solid #e5e7eb;\n      max-width: 400px;\n      margin: 0 auto;\n    `;\n    \n    // 이벤트 리스너\n    banner.querySelector('#install-accept').addEventListener('click', async () => {\n      try {\n        await deferredPrompt.prompt();\n        const choiceResult = await deferredPrompt.userChoice;\n        \n        this.trackInstallPromptResult(choiceResult.outcome);\n        banner.remove();\n        \n      } catch (error) {\n        console.error('설치 프롬프트 오류:', error);\n      }\n    });\n    \n    banner.querySelector('#install-dismiss').addEventListener('click', () => {\n      localStorage.setItem('pwa-install-dismissed', Date.now().toString());\n      banner.classList.remove('visible');\n      setTimeout(() => banner.remove(), 300);\n      \n      this.trackInstallPromptResult('dismissed');\n    });\n    \n    // CSS 추가\n    if (!document.getElementById('install-prompt-styles')) {\n      const styles = document.createElement('style');\n      styles.id = 'install-prompt-styles';\n      styles.textContent = `\n        #pwa-install-banner.visible { bottom: 16px; }\n        \n        .install-content {\n          display: flex;\n          align-items: center;\n          padding: 16px;\n          gap: 12px;\n        }\n        \n        .install-icon {\n          font-size: 24px;\n          flex-shrink: 0;\n        }\n        \n        .install-text {\n          flex: 1;\n          min-width: 0;\n        }\n        \n        .install-title {\n          font-size: 16px;\n          font-weight: 600;\n          color: #111827;\n          margin-bottom: 2px;\n        }\n        \n        .install-subtitle {\n          font-size: 14px;\n          color: #6b7280;\n        }\n        \n        .install-actions {\n          display: flex;\n          gap: 8px;\n          flex-shrink: 0;\n        }\n        \n        .install-btn {\n          padding: 8px 16px;\n          border-radius: 6px;\n          border: none;\n          font-size: 14px;\n          font-weight: 500;\n          cursor: pointer;\n          transition: all 150ms ease;\n        }\n        \n        .install-btn--primary {\n          background: #6366f1;\n          color: white;\n        }\n        \n        .install-btn--primary:hover {\n          background: #5856eb;\n        }\n        \n        .install-btn--secondary {\n          background: #f3f4f6;\n          color: #374151;\n        }\n        \n        .install-btn--secondary:hover {\n          background: #e5e7eb;\n        }\n        \n        @media (max-width: 480px) {\n          .install-actions {\n            flex-direction: column;\n          }\n          \n          .install-btn {\n            width: 100%;\n          }\n        }\n      `;\n      document.head.appendChild(styles);\n    }\n    \n    return banner;\n  }\n  \n  /**\n   * 앱 설치 완료 처리\n   */\n  handleAppInstalled() {\n    // 설치 완료 알림\n    this.showInstallSuccessMessage();\n    \n    // 설치 프롬프트 제거\n    const installBanner = document.getElementById('pwa-install-banner');\n    if (installBanner) {\n      installBanner.remove();\n    }\n    \n    // 설치 완료 추적\n    this.trackEvent('pwa_installed', {\n      timestamp: Date.now(),\n      user_agent: navigator.userAgent,\n    });\n  }\n  \n  /**\n   * 성능 메트릭 보고\n   */\n  reportPerformanceMetrics() {\n    const metrics = {\n      ...this.metrics,\n      timestamp: Date.now(),\n      page: document.documentElement.dataset.page || 'unknown',\n      viewport: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n      },\n      connection: this.getConnectionInfo(),\n    };\n    \n    // 분석 도구로 전송\n    this.trackEvent('app_shell_performance', metrics);\n    \n    // 콘솔에 성능 요약 출력\n    console.group('[App Shell] 성능 메트릭');\n    console.log('Shell 로딩 시간:', `${metrics.shellLoadTime.toFixed(2)}ms`);\n    console.log('컨텐츠 로딩 시간:', `${metrics.contentLoadTime.toFixed(2)}ms`);\n    console.log('총 로딩 시간:', `${metrics.totalLoadTime.toFixed(2)}ms`);\n    console.log('컴포넌트 로딩 시간:', Object.fromEntries(metrics.resourceLoadTimes));\n    console.groupEnd();\n  }\n  \n  /**\n   * 유틸리티 메서드들\n   */\n  \n  async getFromCache(key) {\n    try {\n      const cache = await caches.open('app-shell-v1');\n      const response = await cache.match(key);\n      return response ? await response.text() : null;\n    } catch {\n      return null;\n    }\n  }\n  \n  async saveToCache(key, data) {\n    try {\n      const cache = await caches.open('app-shell-v1');\n      await cache.put(key, new Response(data));\n    } catch (error) {\n      console.warn('캐시 저장 실패:', error);\n    }\n  }\n  \n  isScriptLoaded(src) {\n    return Array.from(document.scripts).some(script => script.src.includes(src));\n  }\n  \n  async resourceExists(url) {\n    try {\n      const response = await fetch(url, { method: 'HEAD' });\n      return response.ok;\n    } catch {\n      return false;\n    }\n  }\n  \n  async loadScript(src) {\n    return new Promise((resolve, reject) => {\n      const script = document.createElement('script');\n      script.src = src;\n      script.type = 'module';\n      script.onload = resolve;\n      script.onerror = reject;\n      document.head.appendChild(script);\n    });\n  }\n  \n  getConnectionInfo() {\n    if ('connection' in navigator) {\n      const conn = navigator.connection;\n      return {\n        effectiveType: conn.effectiveType,\n        downlink: conn.downlink,\n        rtt: conn.rtt,\n      };\n    }\n    return null;\n  }\n  \n  dispatchEvent(eventName, detail) {\n    window.dispatchEvent(new CustomEvent(`appshell:${eventName}`, { detail }));\n  }\n  \n  trackEvent(eventName, eventData) {\n    if (typeof gtag !== 'undefined') {\n      gtag('event', eventName, eventData);\n    }\n  }\n  \n  trackInstallPromptResult(outcome) {\n    this.trackEvent('pwa_install_prompt', {\n      outcome,\n      timestamp: Date.now(),\n    });\n  }\n  \n  // ... 기타 유틸리티 메서드들\n  \n  /**\n   * 오류 처리 메서드들\n   */\n  \n  handleShellLoadError(error) {\n    console.error('[App Shell] Shell 로딩 실패, 기본 UI로 전환');\n    \n    // 기본 네비게이션 표시\n    this.showFallbackNavigation();\n    \n    // 오류 추적\n    this.trackEvent('app_shell_error', {\n      type: 'shell_load_failed',\n      error: error.message,\n      timestamp: Date.now(),\n    });\n  }\n  \n  handleContentLoadError(error) {\n    console.error('[App Shell] 컨텐츠 로딩 실패');\n    \n    // 스켈레톤 UI는 유지하되 오류 메시지 표시\n    this.showContentLoadError();\n    \n    // 오류 추적\n    this.trackEvent('app_shell_error', {\n      type: 'content_load_failed',\n      error: error.message,\n      timestamp: Date.now(),\n    });\n  }\n  \n  showFallbackNavigation() {\n    // 간단한 네비게이션 HTML 생성\n    const fallbackNav = `\n      <nav style=\"background: #6366f1; padding: 1rem; color: white;\">\n        <div style=\"max-width: 1200px; margin: 0 auto; display: flex; justify-content: space-between; align-items: center;\">\n          <h1 style=\"margin: 0; font-size: 1.5rem;\">doha.kr</h1>\n          <div>\n            <a href=\"/\" style=\"color: white; text-decoration: none; margin: 0 1rem;\">홈</a>\n            <a href=\"/tests/\" style=\"color: white; text-decoration: none; margin: 0 1rem;\">테스트</a>\n            <a href=\"/tools/\" style=\"color: white; text-decoration: none; margin: 0 1rem;\">도구</a>\n          </div>\n        </div>\n      </nav>\n    `;\n    \n    const navElement = document.querySelector(this.config.shell.navbar);\n    if (navElement) {\n      navElement.innerHTML = fallbackNav;\n    }\n  }\n  \n  showContentLoadError() {\n    const mainElement = document.querySelector(this.config.shell.mainContent);\n    if (mainElement) {\n      const errorHTML = `\n        <div style=\"text-align: center; padding: 3rem 1rem; max-width: 500px; margin: 0 auto;\">\n          <div style=\"font-size: 3rem; margin-bottom: 1rem;\">⚠️</div>\n          <h2 style=\"color: #374151; margin-bottom: 1rem;\">컨텐츠 로딩 실패</h2>\n          <p style=\"color: #6b7280; margin-bottom: 2rem;\">페이지를 불러오는데 문제가 발생했습니다.</p>\n          <button onclick=\"window.location.reload()\" \n                  style=\"background: #6366f1; color: white; border: none; padding: 0.75rem 1.5rem; border-radius: 0.5rem; cursor: pointer;\">\n            페이지 새로고침\n          </button>\n        </div>\n      `;\n      \n      mainElement.innerHTML = errorHTML;\n    }\n  }\n  \n  showInstallSuccessMessage() {\n    // 설치 성공 토스트 메시지\n    const toast = document.createElement('div');\n    toast.style.cssText = `\n      position: fixed;\n      top: 20px;\n      right: 20px;\n      background: #10b981;\n      color: white;\n      padding: 16px;\n      border-radius: 8px;\n      box-shadow: 0 4px 12px rgba(0,0,0,0.15);\n      z-index: 1001;\n      font-weight: 500;\n      transform: translateX(100%);\n      transition: transform 300ms ease;\n    `;\n    \n    toast.textContent = '앱이 성공적으로 설치되었습니다!';\n    document.body.appendChild(toast);\n    \n    // 애니메이션\n    setTimeout(() => {\n      toast.style.transform = 'translateX(0)';\n    }, 100);\n    \n    // 3초 후 제거\n    setTimeout(() => {\n      toast.style.transform = 'translateX(100%)';\n      setTimeout(() => toast.remove(), 300);\n    }, 3000);\n  }\n  \n  // ... 기타 메서드들 계속\n}\n\n// 전역 인스턴스 생성\nif (typeof window !== 'undefined') {\n  window.AppShell = AppShell;\n  \n  // DOM 준비 시 자동 초기화\n  if (document.readyState === 'loading') {\n    document.addEventListener('DOMContentLoaded', () => {\n      window.appShell = new AppShell();\n    });\n  } else {\n    window.appShell = new AppShell();\n  }\n}\n\nexport default AppShell;"