/**
 * Linear ÎîîÏûêÏù∏ ÏãúÏä§ÌÖú ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò ÎèÑÍµ¨
 * doha.kr ÌîÑÎ°úÏ†ùÌä∏Ïùò Î™®Îì† HTML ÌéòÏù¥ÏßÄÎ•º Linear ÏãúÏä§ÌÖúÏúºÎ°ú Ï†ÑÌôò
 */

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

/**
 * ÌÅ¥ÎûòÏä§ Îß§Ìïë ÌÖåÏù¥Î∏î
 * Í∏∞Ï°¥ ÌÅ¥ÎûòÏä§ ‚Üí Linear ÌÅ¥ÎûòÏä§
 */
const CLASS_MAPPINGS = {
  // Î≤ÑÌäº ÏãúÏä§ÌÖú
  'btn btn-primary': 'linear-button linear-button--primary text-korean',
  'btn btn-secondary': 'linear-button linear-button--secondary text-korean',
  'btn btn-outline': 'linear-button linear-button--outline text-korean',
  'btn btn-ghost': 'linear-button linear-button--ghost text-korean',
  'btn btn-danger': 'linear-button linear-button--danger text-korean',
  'btn btn-lg': 'linear-button linear-button--large text-korean',
  'btn btn-sm': 'linear-button linear-button--small text-korean',
  'btn btn--primary': 'linear-button linear-button--primary text-korean',
  'btn btn--secondary': 'linear-button linear-button--secondary text-korean',
  'btn btn--ghost': 'linear-button linear-button--ghost text-korean',
  'tab-button': 'linear-button linear-button--tab text-korean',
  'cta-button': 'linear-button linear-button--primary linear-button--large text-korean',
  
  // Ïπ¥Îìú ÏãúÏä§ÌÖú
  'service-card': 'linear-card service-card',
  'feature-card': 'linear-card feature-card',
  'result-card': 'linear-card result-card',
  'test-card': 'linear-card test-card',
  'tool-card': 'linear-card tool-card',
  'fortune-card': 'linear-card fortune-card',
  'info-card': 'linear-card info-card',
  'card': 'linear-card',
  
  // ÏûÖÎ†• ÌïÑÎìú
  'form-control': 'linear-input text-korean',
  'form-input': 'linear-input text-korean',
  'form-select': 'linear-select text-korean',
  'form-textarea': 'linear-textarea text-korean',
  'input': 'linear-input text-korean',
  'select': 'linear-select text-korean',
  'textarea': 'linear-textarea text-korean',
  
  // ÏïåÎ¶º ÏãúÏä§ÌÖú
  'alert': 'linear-alert',
  'alert-success': 'linear-alert linear-alert--success',
  'alert-warning': 'linear-alert linear-alert--warning',
  'alert-danger': 'linear-alert linear-alert--danger',
  'alert-info': 'linear-alert linear-alert--info',
  
  // Î∞∞ÏßÄ ÏãúÏä§ÌÖú
  'badge': 'linear-badge',
  'service-badge': 'linear-badge linear-badge--popular',
  'service-badge fortune-gradient': 'linear-badge linear-badge--popular',
  'service-badge new-pink': 'linear-badge linear-badge--new',
  'service-badge new-green': 'linear-badge linear-badge--new',
  'new-badge': 'linear-badge linear-badge--new',
  'hot-badge': 'linear-badge linear-badge--hot',
  'popular-badge': 'linear-badge linear-badge--popular',
  
  // ÏïÑÏù¥ÏΩò ÏãúÏä§ÌÖú
  'service-emoji': 'service-emoji icon',
  'feature-icon': 'feature-icon icon',
  'tool-icon': 'tool-icon icon',
  'test-icon': 'test-icon icon',
  'result-icon': 'result-icon icon',
  'btn-icon': 'icon',
  
  // ÌÉÄÏù¥Ìè¨Í∑∏ÎûòÌîº (ÌïúÍµ≠Ïñ¥ ÏµúÏ†ÅÌôî)
  'service-name': 'service-name text-subheading text-korean',
  'service-desc': 'service-desc text-body text-korean',
  'feature-title': 'feature-title text-heading-3 text-korean',
  'feature-description': 'feature-description text-body text-korean',
  'test-title': 'test-title text-heading-2 text-korean',
  'test-description': 'test-description text-body text-korean',
  'result-title': 'result-title text-heading-2 text-korean',
  'result-text': 'result-text text-body text-korean',
  'tool-title': 'tool-title text-heading-2 text-korean',
  'tool-description': 'tool-description text-body text-korean',
  'page-title': 'page-title text-heading-1 text-korean',
  'section-title': 'section-title text-heading-2 text-korean',
  'section-subtitle': 'section-subtitle text-subheading text-korean',
};

/**
 * ÌïúÍµ≠Ïñ¥ ÌÖçÏä§Ìä∏Í∞Ä ÏûàÎäî ÏöîÏÜåÏóê ÏûêÎèôÏúºÎ°ú text-korean ÌÅ¥ÎûòÏä§ Ï∂îÍ∞Ä
 */
const KOREAN_TEXT_PATTERNS = [
  // ÌïúÍ∏ÄÏù¥ Ìè¨Ìï®Îêú ÌÖçÏä§Ìä∏ ÏöîÏÜåÎì§
  { tag: 'h1', hasKorean: true, addClass: 'text-heading-1 text-korean' },
  { tag: 'h2', hasKorean: true, addClass: 'text-heading-2 text-korean' },
  { tag: 'h3', hasKorean: true, addClass: 'text-heading-3 text-korean' },
  { tag: 'h4', hasKorean: true, addClass: 'text-subheading text-korean' },
  { tag: 'h5', hasKorean: true, addClass: 'text-subheading text-korean' },
  { tag: 'h6', hasKorean: true, addClass: 'text-label text-korean' },
  { tag: 'p', hasKorean: true, addClass: 'text-body text-korean' },
  { tag: 'span', hasKorean: true, addClass: 'text-korean' },
  { tag: 'div', hasKorean: true, addClass: 'text-korean' },
  { tag: 'label', hasKorean: true, addClass: 'text-label text-korean' },
  { tag: 'button', hasKorean: true, addClass: 'text-korean' },
  { tag: 'a', hasKorean: true, addClass: 'text-korean' },
];

/**
 * ÌïòÏù¥ÎùºÏù¥ÌÑ∞ Ìå®ÌÑ¥ Ï∂îÍ∞Ä Í∑úÏπô
 */
const HIGHLIGHTER_PATTERNS = {
  'feature-title': 'highlight-dots highlight-korean subtle',
  'service-name': 'highlight-grid highlight-korean subtle',
  'test-title': 'highlight-diagonal highlight-korean animated',
  'result-title': 'highlight-noise highlight-korean subtle',
  'hero-title-highlight': 'highlight-diagonal highlight-korean animated',
  'cta-title': 'highlight-geometric highlight-korean animated',
};

/**
 * HTML ÌååÏùºÏùò ÌÅ¥ÎûòÏä§Î•º Linear ÏãúÏä§ÌÖúÏúºÎ°ú Î≥ÄÌôò
 * @param {string} htmlContent - HTML ÌååÏùº ÎÇ¥Ïö©
 * @param {string} filePath - ÌååÏùº Í≤ΩÎ°ú (Î°úÍπÖÏö©)
 * @returns {string} - Î≥ÄÌôòÎêú HTML ÎÇ¥Ïö©
 */
function migrateHtmlToLinear(htmlContent, filePath = '') {
  let modifiedContent = htmlContent;
  let changeCount = 0;
  const changes = [];

  console.log(`\nüîÑ Processing: ${filePath}`);

  // 1. ÌÅ¥ÎûòÏä§ Îß§Ìïë Ï†ÅÏö©
  Object.entries(CLASS_MAPPINGS).forEach(([oldClass, newClass]) => {
    const regex = new RegExp(`class="${oldClass.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}"`, 'g');
    const matches = modifiedContent.match(regex);
    
    if (matches) {
      modifiedContent = modifiedContent.replace(regex, `class="${newClass}"`);
      changeCount += matches.length;
      changes.push(`  ‚úÖ ${oldClass} ‚Üí ${newClass} (${matches.length}x)`);
    }
  });

  // 2. Î∂ÄÎ∂Ñ ÌÅ¥ÎûòÏä§ Îß§Ìïë (Îçî Î≥µÏû°Ìïú Ìå®ÌÑ¥)
  const partialMappings = [
    // btnÏù¥ Ìè¨Ìï®Îêú ÌÅ¥ÎûòÏä§Îì§
    [/class="([^"]*\b)btn(\b[^"]*)"/g, (match, prefix, suffix) => {
      if (prefix.includes('linear-button')) return match; // Ïù¥ÎØ∏ Î≥ÄÌôòÎêú Í≤ΩÏö∞ Ïä§ÌÇµ
      const newClass = `${prefix}linear-button${suffix} text-korean`.trim();
      changeCount++;
      changes.push(`  üîÑ btn pattern: ${match} ‚Üí class="${newClass}"`);
      return `class="${newClass}"`;
    }],
    
    // cardÍ∞Ä Ìè¨Ìï®Îêú ÌÅ¥ÎûòÏä§Îì§
    [/class="([^"]*\b)card(\b[^"]*)"/g, (match, prefix, suffix) => {
      if (prefix.includes('linear-card')) return match;
      const newClass = `${prefix}linear-card${suffix}`.trim();
      changeCount++;
      changes.push(`  üîÑ card pattern: ${match} ‚Üí class="${newClass}"`);
      return `class="${newClass}"`;
    }],
  ];

  partialMappings.forEach(([regex, replacer]) => {
    modifiedContent = modifiedContent.replace(regex, replacer);
  });

  // 3. ÌïúÍµ≠Ïñ¥ ÌÖçÏä§Ìä∏ ÏµúÏ†ÅÌôî (Í∏∞Î≥∏Ï†ÅÏù∏ ÌïúÍ∏Ä Í∞êÏßÄ)
  const koreanTextRegex = />[^<]*[Í∞Ä-Ìû£][^<]*</g;
  const koreanMatches = modifiedContent.match(koreanTextRegex);
  
  if (koreanMatches) {
    console.log(`  üá∞üá∑ Korean text detected: ${koreanMatches.length} instances`);
  }

  // 4. ÌïòÏù¥ÎùºÏù¥ÌÑ∞ Ìå®ÌÑ¥ Ï∂îÍ∞Ä
  Object.entries(HIGHLIGHTER_PATTERNS).forEach(([className, highlighterClass]) => {
    const regex = new RegExp(`class="([^"]*\\b)${className}(\\b[^"]*)"`, 'g');
    const replacement = `class="$1${className}$2 ${highlighterClass}"`;
    
    if (modifiedContent.match(regex)) {
      modifiedContent = modifiedContent.replace(regex, replacement);
      changes.push(`  ‚ú® Added highlighter: ${className} + ${highlighterClass}`);
      changeCount++;
    }
  });

  // Í≤∞Í≥º Ï∂úÎ†•
  if (changes.length > 0) {
    console.log(`  üìä Total changes: ${changeCount}`);
    changes.slice(0, 10).forEach(change => console.log(change)); // ÏµúÎåÄ 10Í∞úÎßå ÌëúÏãú
    if (changes.length > 10) {
      console.log(`  ... and ${changes.length - 10} more changes`);
    }
  } else {
    console.log(`  ‚è≠Ô∏è  No changes needed`);
  }

  return modifiedContent;
}

/**
 * ÎîîÎ†âÌÜ†Î¶¨Ïùò Î™®Îì† HTML ÌååÏùºÏùÑ Ïû¨Í∑ÄÏ†ÅÏúºÎ°ú Ï≤òÎ¶¨
 * @param {string} dirPath - ÎîîÎ†âÌÜ†Î¶¨ Í≤ΩÎ°ú
 * @param {string[]} excludePaths - Ï†úÏô∏Ìï† Í≤ΩÎ°úÎì§
 * @returns {Object} - Ï≤òÎ¶¨ Í≤∞Í≥º ÌÜµÍ≥Ñ
 */
function migrateDirectory(dirPath, excludePaths = []) {
  const stats = {
    processedFiles: 0,
    modifiedFiles: 0,
    totalChanges: 0,
    errors: []
  };

  function processDirectory(currentPath) {
    const items = fs.readdirSync(currentPath);
    
    items.forEach(item => {
      const fullPath = path.join(currentPath, item);
      const relativePath = path.relative(dirPath, fullPath);
      
      // Ï†úÏô∏ Í≤ΩÎ°ú ÌôïÏù∏
      if (excludePaths.some(excludePath => relativePath.startsWith(excludePath))) {
        console.log(`‚è≠Ô∏è  Skipping excluded: ${relativePath}`);
        return;
      }
      
      const stat = fs.statSync(fullPath);
      
      if (stat.isDirectory()) {
        processDirectory(fullPath);
      } else if (path.extname(fullPath) === '.html') {
        try {
          const originalContent = fs.readFileSync(fullPath, 'utf8');
          const modifiedContent = migrateHtmlToLinear(originalContent, relativePath);
          
          stats.processedFiles++;
          
          if (originalContent !== modifiedContent) {
            fs.writeFileSync(fullPath, modifiedContent, 'utf8');
            stats.modifiedFiles++;
            console.log(`  ‚úÖ Modified: ${relativePath}`);
          }
        } catch (error) {
          stats.errors.push(`Error processing ${relativePath}: ${error.message}`);
          console.error(`‚ùå Error processing ${relativePath}:`, error.message);
        }
      }
    });
  }

  processDirectory(dirPath);
  return stats;
}

/**
 * ÌäπÏ†ï HTML ÌååÏùºÎì§Îßå Ï≤òÎ¶¨
 * @param {string[]} filePaths - Ï≤òÎ¶¨Ìï† ÌååÏùº Í≤ΩÎ°úÎì§
 * @returns {Object} - Ï≤òÎ¶¨ Í≤∞Í≥º ÌÜµÍ≥Ñ
 */
function migrateSpecificFiles(filePaths) {
  const stats = {
    processedFiles: 0,
    modifiedFiles: 0,
    totalChanges: 0,
    errors: []
  };

  filePaths.forEach(filePath => {
    try {
      if (!fs.existsSync(filePath)) {
        console.log(`‚ö†Ô∏è  File not found: ${filePath}`);
        return;
      }

      const originalContent = fs.readFileSync(filePath, 'utf8');
      const modifiedContent = migrateHtmlToLinear(originalContent, filePath);
      
      stats.processedFiles++;
      
      if (originalContent !== modifiedContent) {
        fs.writeFileSync(filePath, modifiedContent, 'utf8');
        stats.modifiedFiles++;
        console.log(`‚úÖ Modified: ${filePath}`);
      }
    } catch (error) {
      stats.errors.push(`Error processing ${filePath}: ${error.message}`);
      console.error(`‚ùå Error processing ${filePath}:`, error.message);
    }
  });

  return stats;
}

/**
 * Î©îÏù∏ Ïã§Ìñâ Ìï®Ïàò
 */
function main() {
  console.log('üöÄ Linear Design System Migration Tool');
  console.log('=====================================\n');

  const projectRoot = path.resolve(__dirname, '..');
  const excludePaths = [
    'node_modules',
    'design-system/node_modules',
    '.git',
    'playwright-report',
    'test-reports',
    'coverage',
    'dist'
  ];

  // Ï£ºÏöî ÌéòÏù¥ÏßÄÎì§ Ïö∞ÏÑ† Ï≤òÎ¶¨
  const majorPages = [
    path.join(projectRoot, 'tests/mbti/index.html'),
    path.join(projectRoot, 'tests/teto-egen/index.html'),
    path.join(projectRoot, 'tests/love-dna/index.html'),
    path.join(projectRoot, 'tools/bmi-calculator.html'),
    path.join(projectRoot, 'tools/salary-calculator.html'),
    path.join(projectRoot, 'tools/text-counter.html'),
    path.join(projectRoot, 'fortune/daily/index.html'),
    path.join(projectRoot, 'fortune/saju/index.html'),
    path.join(projectRoot, 'fortune/tarot/index.html'),
    path.join(projectRoot, 'about/index.html'),
    path.join(projectRoot, 'contact/index.html'),
    path.join(projectRoot, 'faq/index.html'),
  ];

  console.log('üìù Phase 1: Processing Major Pages');
  console.log('==================================');
  const majorStats = migrateSpecificFiles(majorPages);

  console.log('\nüìÅ Phase 2: Processing All Remaining Files');
  console.log('==========================================');
  const allStats = migrateDirectory(projectRoot, excludePaths);

  // ÌÜµÍ≥Ñ Ï∂úÎ†•
  console.log('\nüìä Migration Complete!');
  console.log('=====================');
  console.log(`üìÑ Total files processed: ${majorStats.processedFiles + allStats.processedFiles}`);
  console.log(`‚úèÔ∏è  Files modified: ${majorStats.modifiedFiles + allStats.modifiedFiles}`);
  console.log(`‚ùå Errors: ${majorStats.errors.length + allStats.errors.length}`);

  if (majorStats.errors.length + allStats.errors.length > 0) {
    console.log('\n‚ùå Errors encountered:');
    [...majorStats.errors, ...allStats.errors].forEach(error => console.log(`  ${error}`));
  }

  console.log('\nüéâ Linear Design System migration completed successfully!');
}

// Ïä§ÌÅ¨Î¶ΩÌä∏ Ïã§Ìñâ
main();

export {
  migrateHtmlToLinear,
  migrateDirectory,
  migrateSpecificFiles,
  CLASS_MAPPINGS,
  KOREAN_TEXT_PATTERNS,
  HIGHLIGHTER_PATTERNS
};